<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Haskell Diary 1 - Recursion | Akash Agrawal</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Haskell Diary 1 - Recursion" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="See how lazy loading in Haskell makes some very clever code possible" />
<meta property="og:description" content="See how lazy loading in Haskell makes some very clever code possible" />
<link rel="canonical" href="https://akagr.github.io/2016/01/31/haskell-diary-1-recursion.html" />
<meta property="og:url" content="https://akagr.github.io/2016/01/31/haskell-diary-1-recursion.html" />
<meta property="og:site_name" content="Akash Agrawal" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-01-31T00:00:00-06:00" />
<script type="application/ld+json">
{"url":"https://akagr.github.io/2016/01/31/haskell-diary-1-recursion.html","@type":"BlogPosting","headline":"Haskell Diary 1 - Recursion","dateModified":"2016-01-31T00:00:00-06:00","datePublished":"2016-01-31T00:00:00-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://akagr.github.io/2016/01/31/haskell-diary-1-recursion.html"},"description":"See how lazy loading in Haskell makes some very clever code possible","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://akagr.github.io/feed.xml" title="Akash Agrawal" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />

<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Akash Agrawal</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Haskell Diary 1 - Recursion</h1><p class="page-description">See how lazy loading in Haskell makes some very clever code possible</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2016-01-31T00:00:00-06:00" itemprop="datePublished">
        Jan 31, 2016
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      6 min read
    
</span></p>

    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Haskell is the first pure functional programming language that I have had a serious contact with. I’m very much a noob right now but I’ve found that there’s a lot of gold to be found right from day 1 in functional world. So I’ve thought about documenting things which I found really cool, mind bending or which simply took a long time for me to wrap my head around (still, cool).</p>

<p>So… recursion.</p>

<p>I’ll get killed in the street if I said that Haskell can do recursion. Of course Haskell can do recursion. C can do recursion. Javascript can do recursion. Ruby, Java (and most other languages) can do it too.</p>

<p>The reason why I’m talking about recursion in Haskell is because of its support for infinite lists. More specifically, the reason I’m <em>really</em> talking about recursion is because of an example I came across which blew me away. Some background for the uninitiated first.</p>

<blockquote>
  <p>Recursion means a function calling itself</p>
</blockquote>

<p>Bet anyone reading this already knew that. A classic example of recursion is fibonacci series. So here’s a naive program which probably every programmer has seen in their language(s) of choice.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibonacci</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fibonacci</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fibonacci</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>The reason it’s called naive is because it’s neither the most efficient nor the most elegant way of doing things. On my 2014 macbook pro with core i5, <code class="language-plaintext highlighter-rouge">fibonacci 1</code> gives result instantly. <code class="language-plaintext highlighter-rouge">fibonacci 25</code> seems a fraction of a second slower. <code class="language-plaintext highlighter-rouge">fibonacci 50</code> hasn’t yielded results yet and I executed it 11 minutes ago.</p>

<p>Back on track, I came across following implementation of fibonacci while learning the basics of Haskell. It gives me results for 1000 instantaneously and doesn’t involves memoization or other state-dependent techniques.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>
</code></pre></div></div>

<p>Before diving in the down and low of it, following are (hopefully) self-explanatory examples of some other functions used here.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- tail takes a list and gives it back after removing its first element</span>
<span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="c1">-- &gt; [2, 3, 4, 5]</span>
<span class="n">tail</span> <span class="s">"haskell diary"</span> <span class="c1">-- &gt; "askell diary"</span>

<span class="c1">-- zipWith takes a function and two lists and return the</span>
<span class="c1">-- result of applying that function on corresponding elements</span>
<span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="c1">-- &gt; [5, 7, 9]</span>
<span class="n">zipWith</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span> <span class="c1">-- &gt; [2, 6, 12]</span>
</code></pre></div></div>

<p>Also, let’s reduce some noise by replacing <code class="language-plaintext highlighter-rouge">zipWith (+)</code> by a function which does the same but would look more at-home here. Also, rewrite the above code with our substituted function.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">addLists</span> <span class="o">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="c1">-- addList [1, 2, 3] [4, 5, 6] gives [5, 7, 9]</span>

<span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>
</code></pre></div></div>

<p>Makes better sense. Now, this code generates an infinitely long fibonacci sequence. It does that by recursively adding a list to itself only the second time it shifts it position (using tail) by a place. Let’s try and break it down.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>

<span class="c1">-- expanding by substituting fibs with its own definition</span>
<span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">))</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">))</span>

<span class="c1">-- expanding again by replacing all instances of fibs by</span>
<span class="c1">-- its definition above</span>
<span class="c1">-- warning: keep your brains together now. I'm just replacing stuff.</span>
<span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">))</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)))</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">))</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)))</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">))</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)))</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">))</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)))</span>
</code></pre></div></div>

<p>And it will go on. Point of interest is that, after each expansion, we can apply <code class="language-plaintext highlighter-rouge">addLists</code> to get a number out. Let’s not do any further expansion (and risk fainting) and instead start working our way back to simplify by discarding and condensing. So we take as much as is concrete (does not require expansion) from the innermost list and discard the rest.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1">-- writing lists in common format (0 : 1 : [] == [0, 1])</span>
<span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1">-- simplifying</span>
<span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">(</span><span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1">-- writing lists in common format</span>
<span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1">-- simplifying</span>
<span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">--&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>See? What we did was, we expanded <code class="language-plaintext highlighter-rouge">fibs</code> fully two times. And by discarding further expansions and simplifying, we added two new elements to our list. Note that we already began with 0 and 1.</p>

<p>We can easily write a small piece of code on top of this which returns the nth fibonacci number.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibs</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">addLists</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>

<span class="n">fibonacci</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">$</span> <span class="n">take</span> <span class="n">n</span> <span class="n">fibs</span>
</code></pre></div></div>

<p>Let’s say <code class="language-plaintext highlighter-rouge">n = 30</code>. So it’ll request 30 elements from <code class="language-plaintext highlighter-rouge">fibs</code>. Then, give us the last element of that 30 element list. i.e. the 30th element.</p>

<p>My biggest takeaway from this algorithm of fibonacci was that I need some time to get easy with infinite lists. I am used to approaching recursion from top-down. That means, start recursing and stop on some condition to yield result. That’s how our naive approach works too.</p>

<p>This code does the opposite. It starts from 0 and never stops (theoretically). It will never reach a last element. The reason we’re able to get away with writing this is that Haskell is lazy. It will only execute code if it really needs to. This is a huge departure from the strict evaluation that I’m used to.</p>

<p>So when we do a <code class="language-plaintext highlighter-rouge">take 30 fibs</code>, it’ll start recursing. And since since we told it to actually give us 30 elements, it will start simplifying too. It allows us to extract elements from its front as it goes on building that list further and further. Once it has given us enough elements, it gives up calculating more. It simply isn’t fussed about actually completing the list of all fibonacci numbers, in other words. Interesting, right?</p>

<p>While I know enough about recursion and Haskell library functions to try and explain how and why this code works, I imagine it’d take a bit of time for me to come up with such solutions myself. Hopefully sooner than later.</p>

<p>Let me know your thoughts below or over at <a href="https://www.reddit.com/r/haskell/comments/43imla/haskell_diary_1_recursion/">reddit thread</a> for this post.</p>

<p><strong>Update 1</strong>:
As <em>/u/twistier</em> pointed out over at reddit, a better definition of recursion would be <em>a value, which may or may not be a function, being self referential</em>.</p>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="akagr/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/2016/01/31/haskell-diary-1-recursion.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Lessons and ramblings. Thoughts and speculations. Opinions are my own.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/akagr" title="akagr"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/akshagrwl" title="akshagrwl"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
