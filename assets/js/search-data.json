{
  
    
        "post0": {
            "title": "Cleaning merged Git branches",
            "content": "Doing some git house cleaning is something that gets neglected more often than not. With zero-cost branches in git (unlike svn), most developers creates zillions of branches during the course of their projects. Most git workflows see creation of every unit of work being put under its own branch. This means individual branches for features, bug fixes, hot fixes etc. . It’s very desirable to keep our git repos clean of branches that are no longer useful/relevant. Have too many unnecessary branches also pollutes git logs since it’s more difficult to locate a particular branch’s head when there are hundreds of those. . Here are a couple of really quick shell commands to tame this situation . Finding all the merged branches . First, we switch to master and bring in all the updates. This is important if we don’t want to lose branches that haven’t yet been merged to master. . git checkout master git pull origin master . Then, we can list all the merged branches, both local and remote with: . git branch --merged git branch -r --merged . This gives some good info of the stuff we’re going to delete. We need to make sure there’s nothing in here that we don’t want to delete. . It should be noted that master is also listed amongst merged branches. We obviously don’t want to delete that. Good ol’ grep to the rescue. . git branch --merged | grep -E -v &quot;(^ *|master)&quot; git branch -r --merged | grep -E -v &quot;(^ *|master)&quot; . The resulting lists of branches will be our candidates for deletion. . Deleting all the merged branches . Now that we know what to delete: . git branch --merged | grep -E -v &quot;(^ *|master)&quot; | xargs git branch -d git branch -r --merged | grep -E -v &quot;(^ *|master)&quot; | sed &#39;s/origin ///&#39; | xargs git push origin --delete . Note the addition of sed in our pipeline for deletion of remote branches. That’s because we need to strip the origin/ part from the names to make them compatible with the consequent git push. . Hope this makes it easier to keep the branch population under control. . Have a comment? Reply on @akshagrwl. .",
            "url": "https://akagr.github.io/2017/10/03/cleaning-git-branches.html",
            "relUrl": "/2017/10/03/cleaning-git-branches.html",
            "date": " • Oct 3, 2017"
        }
        
    
  
    
        ,"post1": {
            "title": "Accessing child elements in Angular / Ionic",
            "content": "Components are at the heart of Angular, and we have some very useful tools to work with them efficiently. Often, we need to access the children - child elements, in other words - of our components. This can mean getting a reference to the DOM element, or to the actual component object if one exists. For this, we have at our disposal two handy decorators @ViewChild and @ContentChild, along with their list counterparts - @ViewChildren and @ContentChildren. Let’s see why there are two of these and how we can use them. . Before we begin . We’ll create a very simple counter component. All it will do is display its property and have a method we can use to increment it. We’ll demonstrate how to access this component’s increment method to increase the value later. . @Component({ selector: &#39;counter&#39;, template: &#39;&lt;h2&gt;&lt;/h2&gt;&#39; }) export class Counter { counter: number = 123; increment() { this.counter++; } } . Children in component’s template . There are two places a component can have child elements - template and content. Let’s talk template children first. Observe the following component: . @Component({ selector: &#39;my-app&#39;, template: ` &lt;my-dialog&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/my-dialog&gt; ` }) export class AppComponent { } . Here, both - my-dialog and counter are children of AppComponent in its template. Let’s assume that we have my-dialog defined for now. If we want to access the counter here, we’ll use the @ViewChild decorator as follows: . @Component({ selector: &#39;my-app&#39;, template: ` &lt;button (click)=&quot;counter.increment()&quot;&gt;Increment View Child &lt;/button&gt; &lt;my-dialog&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/my-dialog&gt; ` }) export class AppComponent { @ViewChild(Counter) counter: Counter; } . We’ve added a button to make it easy to play with this example. The @ViewChild decorator can take either a type of component or a selector (string) as argument, and returns the first child element from template that matches it. In this case, since we have a Counter component, we get the reference to actual component object that’s rendered. Clicking the button increases the counter to 124, proving this. . Children in component’s projected content . In the last example, since both - my-dialog and counter are present inside the template of AppComponent, we can access them with @ViewChildren. However, counter also seems to be a child of my-dialog, although not in its own template. Here’s the definition of MyDialog as we have it for now: . @Component({ selector: &#39;my-dialog&#39;, template: `&lt;ng-content&gt;&lt;/ng-content&gt;` }) export class MyDialog { } . All this component does is project the content that was provided as its child. This is referred to as transclusion. That said, there is a way of accessing the children in the projected component - @ContentChild. . Let’s modify our MyDialog component a bit. Here’s what the entire code ends up looking like: . @Component({ selector: &#39;my-dialog&#39;, template: ` &lt;button (click)=&quot;counter.increment()&quot;&gt;Increment Content Child &lt;/button&gt; &lt;ng-content&gt;&lt;/ng-content&gt; ` }) export class MyDialog { @ContentChild(Counter) counter: Counter; } @Component({ selector: &#39;my-app&#39;, template: ` &lt;button (click)=&quot;counter.increment()&quot;&gt;Increment View Child &lt;/button&gt; &lt;my-dialog&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/my-dialog&gt; ` }) export class AppComponent { @ViewChild(Counter) counter: Counter; } . Both - AppComponent and MyDialog are accessing the same Counter component. AppComponent is using @ViewChild because &lt;counter&gt; is present inside its template. On the other hand, MyDialog is using @ContentChild because &lt;counter&gt; is a part of its projected content, not the template itself. . Matching more than one child . Both the decorators we saw above have a corresponding list version, which matches all the child elements in its scope (template or projected content). Unsurprisingly, they are named @ViewChildren and @ContentChildren. Now that we know the difference in where they look for children, let’s see how we can use @ViewChildren quickly. . @Component({ selector: &#39;my-app&#39;, template: ` &lt;button (click)=&quot;counter.increment()&quot;&gt;Increment View Child &lt;/button&gt; &lt;my-dialog&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/my-dialog&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;button (click)=&quot;incrementChildren()&quot;&gt;Increment View Children &lt;/button&gt; ` }) export class AppComponent { @ViewChild(Counter) counter: Counter; @ViewChildren(Counter) counters: QueryList&lt;Counter&gt;; incrementChildren() { this.counters.forEach(counter =&gt; { counter.increment(); }); } } . We’ve added a bunch of &lt;counter&gt; elements and a button to increment all of them to our template. To support that, we’ve added @ViewChildren decorator to capture all the counter children. It’s important to note that @ViewChildren and @ContentChildren do not return an array. They return a QueryList, which is an array like object. It is an iterable, which means we can use that with ngFor, and has common array methods like forEach which we’ve made use of. The QueryList automatically tracks addition and removal of any children. . Here’s the finished live plunk of this. . In the plunk, notice that clicking on the button to increment view children increments all the counters, including the one we’ve matched with @ViewChild and @ContentChild. Clicking on the corresponding button to increment content and view child continues to increment only the one counter that is matched. When a child can be of more than one type Consider the following bit of code: . @Directive({ selector: &#39;[highlight]&#39; }) export class Highlight { constructor(private el: ElementRef) { } changeColor() { this.el.nativeElement.style.color = &#39;red&#39;; } } @Component({ selector: &#39;my-app&#39;, template: ` &lt;counter highlight&gt;&lt;/counter&gt; &lt;button (click)=&quot;counter.increment()&quot;&gt;Increment View Child&lt;/button&gt; ` }) export class AppComponent { @ViewChild(Counter) counter: Counter; } . What if we wanted to match the &lt;counter&gt; child, but instead of getting the component object back, needed a reference to the attached directive object? In other words, how can we access the changeColor method on our view child? . Fortunately, there’s an easy way to do so. But before we get into that, we need to understand how angular decides what to return to us when it sees a @ViewChild decorator. Up till now, we were getting the component object, which allowed us to interact with component’s methods directly. However, that’s not the end of it. For angular, there can be multiple ways to interpret view-child. It is first and foremost a DOM element. It may also correspond to an angular component. Further, it may also have directives or services attached to it. We can help by telling explicitly what we want. . Turns out, in addition to providing the type/selector of child to match against, we can also provide instructions of interpreting the child object via read property. Our decorator will change thus: . @ViewChild(Counter, {read: Highlight}) counter: Highlight; . Now, counter.increment() will result in error, because counter is no longer a component object. Instead, it represents the directive object, which means counter.changeColor() is the new black. . @Component({ selector: &#39;my-app&#39;, template: ` &lt;counter highlight&gt;&lt;/counter&gt; &lt;button (click)=&quot;counter.increment()&quot;&gt;Increment View Child&lt;/button&gt; &lt;button (click)=&quot;highlight.changeColor()&quot;&gt;Color View Child&lt;/button&gt; ` }) export class AppComponent { @ViewChild(Counter) counter: Counter; @ViewChild(Counter, {read: Highlight}) highlight: Highlight; } . Note that although both the @ViewChild decorators return references to different types of things, in the end, it is all affecting the same element. By specifying the type of reference we want, we can easily switch between our interpretations of an element. . The finished plunk contains another interpretation we can use - as a DOM element - and accesses the native element directly. . Summing up . We saw how we can access child elements using different decorators that angular provides, depending on where those elements might occur. We also learned how we can specify the type of child element directly, and interpret same element in different ways. This opens up new ways of interaction between components in complex scenarios when communication through input/output might not be the best (or practical) approach. .",
            "url": "https://akagr.github.io/2017/10/03/childelements-in-angular.html",
            "relUrl": "/2017/10/03/childelements-in-angular.html",
            "date": " • Oct 3, 2017"
        }
        
    
  
    
        ,"post2": {
            "title": "Beginner's guide to Megaparsec",
            "content": "What is Megaparsec? . Megaparsec is a parsing library written in Haskell. It’s a fork of the popular Parsec and is more up to date. . This post came into being because while there are tutorials for Parsec, there aren’t many for Megaparsec. As a Haskell noob, I found myself discouraged to depend on Parsec tutorials too much, given that Megaparsec may have diverged over time. . Without further ado, let’s get right to it. . Environment and Setup . This post is written against stack, ghc version 8.0.1 and megaparsec version 5.0.1. . We can follow the official docs for info on how to install stack. Once we have it up and running, installing megaparsec is a piece of cake: . $ stack install megaparsec . Note that in a real world project, we’ll be adding megaparsec to our .cabal file, instead of installing it manually like this. However, for the purpose of this tutorial, we’ll be working with a single file instead of a full blown project. . Next, create a Haskell source file; let’s call it myparser.hs. . $ touch myparser.hs . With that done, we have everything we need to begin. All the code examples below should be written in myparser.hs. . Parsing a single letter . Let’s start with the simplest of parsers. We’ll parse a single letter, and output results, based on whether it passed or failed. This should serve a secondary purpose of verifying that we’ve set up everything correctly. . -- myparser.hs module MyParser (main) where import Text.Megaparsec import Text.Megaparsec.String import System.Environment main = do input &lt;- fmap head getArgs parseTest singleLetterP input singleLetterP :: Parser Char singleLetterP = char &#39;h&#39; . Let’s dissect this bit of code. Text.Megaparsec module is the umbrella for all the basic functions from this package. It provides methods such as parseTest, parse etc. along with a host of parsers and combinators. . Text.Megaparsec.String module provides the Parser datatype synonym. In short, this means that we’re dealing with string inputs. There are corresponding modules for ByteString and Text types for when they’re needed. . In the first line of main function, we’re getting the first command line argument. We’re using a partial function head, which is not advised in production code. However, here, it serves our purpose, since the code will now give error if we fail to provide an argument. . The second line of the main function is calling parseTest function. This function takes a parser and input string as arguments. It runs the parser on the input, and prints the results/error to stdout. . Finally, singleLetterP is the actual parser we wrote. Take a note of its datatype. Char in Parser Char tells us what this parser will output. . In the function definition, char function is a utility parser provided by Text.Megaparsec.Char module, which is already included in the Text.Megaparsec import. This parser matches a single letter provided to it as argument. . Let’s run this code and see what happens: . $ stack runghc myparser.hs haskell &#39;h&#39; $ stack runghc myparser.hs javascript 1:1: unexpected &#39;j&#39; expecting &#39;h&#39; . So we get our first working parser, which gives us the result or helpful error messages to boot. . How parsing works . When we run a parser, it begins parsing from the very beginning of input. The parser we write should match the input continuously, or it’ll fail. Also, the parser will match/consume only as much as we’ll tell it to. . For instance, in our example above, when we supplied ‘haskell’ as the input string, it matched h from the very beginning, because that’s all we coded. It stopped matching after that. . If we had provided jhaskell or something else, it’ll still fail. That’s because the parser char &#39;h&#39; will not arbitrarily match ‘h’ from anywhere in the string. It’ll consume a single letter from beginning and pass or fail depending on whether it’s ‘h’. . That said, we’ll see how to tie together multiple parsers which let us skip letters or run multiple parsers over same inputs to see what fits. . Parsing this OR that . What if we have a scenario where we want to be able to run more than one parser on same input, in case the previous one fails. We have a handy infix function &lt;|&gt; for exactly that. . Observe: . -- myparser.hs -- ... imports and module declaration ... main = do input &lt;- fmap head getArgs parseTest singleLetterP input singleLetterP :: Parser Char singleLetterP = char &#39;h&#39; &lt;|&gt; char &#39;j&#39; . Now, this parser will match anything starting with ‘h’ or ‘j’. Here’s our code in action: . $ stack runghc myparser.hs haskell &#39;h&#39; $ stack runghc myparser.hs javascript &#39;j&#39; $ stack runghc myparser.hs ruby 1:1: unexpected &#39;a&#39; expecting &#39;h&#39; or &#39;j&#39; . Even though we’ve only combined two single letter parsers, this infix method &lt;|&gt; works on arbitrarily complex parsers. . Parsing this AND that . As we’ve seen, &lt;|&gt; basically acts as boolean OR function for parsers. But we also want to be able to run more than one parser one after another sequentially, each parser consuming a part of input string, and forwarding the rest onwards. . Fortunately, the datatype Parser a belongs to Monad typeclass. Which means we get the &gt;&gt;= (bind function) to compose multiple parsers. . Let’s modify our code so that our parser will match two letters, one after another. . -- myparser.hs -- ... imports and module declaration ... main = do input &lt;- fmap head getArgs parseTest doubleLetterP input doubleLetterP :: Parser Char doubleLetterP = char &#39;h&#39; &gt;&gt;= ( _ -&gt; char &#39;a&#39;) . Now, our doubleLetterP parser will consume a single letter ‘h’, followed by a single letter ‘a’. . $ stack runghc myparser.hs haskell &#39;a&#39; $ stack runghc myparser.hs hoogle unexpected &#39;o&#39; expecting &#39;a&#39; $ stack runghc myparser.hs assembly 1:1: unexpected &#39;a&#39; expecting &#39;h&#39; . The syntax we’ve used to combine two parsers this way leaves something to be desired. Fortunately, by the virtue of being a member of Monad typeclass, we get the do syntax for free. . Following parser does the exact same thing as the previous example, only with an arguably more readable syntax: . -- myparser.hs -- ... imports and main function ... doubleLetterP :: Parser Char doubleLetterP = do char &#39;h&#39; char &#39;a&#39; . So far, we’ve only been using a single parser - char. There are many other useful parsers which we have in our arsenal out of the box. For the full list, check out the API docs for Text.Megaparsec.Char. . Combinators . Combinators are functions that we use to combine one or more parsers in different ways. We’ve already seen one of them - the &lt;|&gt; function. But that’s neither the only combinator available to us, nor is that that only way we can combine our parsers. . Let’s write a parser to match a word. We define word as a continuous string of alphanumeric characters. Any spaces, tabs and/or special characters are not included. . -- myparser.hs -- ... imports ... main = do input &lt;- fmap head getArgs parseTest wordP input wordP :: Parser String wordP = some alphaNumChar . Firstly, note the change in datatype of our wordP function. Since we now expect our parser to match a string instead of single character, the datatype will reflect that. Feel free to check out what error we get if we change that back to Parser Char. . Secondly, we’ve introduced a combinator here, namely some. This is a function that takes a parser as argument. In our example, alphaNumChar is that argument. some will try to run the parser continuously one or more times as long as it keeps getting successful. . Here’s our new parser in action . $ stack runghc myparser.hs haskell &quot;haskell&quot; $ stack runghc myparser.hs &quot;haskell hoogle&quot; &quot;haskell&quot; $ stack runghc myparser.hs &quot;;haskell&quot; 1:1: unexpected &#39;;&#39; expecting alphanumeric character $ stack runghc myparser.hs &quot;&quot; 1:1: unexpected end of input expecting alphanumeric character . One of the major ups of using megaparsec is the helpful error messages we get without doing anything extra. . Note: There’s also a many combinator which matches 0 or more occurrences of the supplied parser. . Transforming parsed strings . More often than not, if we’re parsing a string, it’s because we want to extract some data out from it and do something with it. For example, we might be parsing an entries from account statement, and we want to convert the parsed balances to a number type. . For this example, we’ll try to parse the bold notation of markdown and convert it to html tag. In markdown, if we have to make text bold, we enclose it in **. For instance, **This is bold** will show up as This is bold after conversion. . Behind the scenes, the markdown converter parses the text inside ** delimiters, and puts it in &lt;strong&gt; tags. Let’s try to write a parser which does this. . -- myparser.hs -- ... imports ... main = do input &lt;- fmap head getArgs parseTest boldP input boldP :: Parser String boldP = do _ &lt;- count 2 (char &#39;*&#39;) txt &lt;- some (alphaNumChar &lt;|&gt; char &#39; &#39;) _ &lt;- count 2 (char &#39;*&#39;) return $ concat [ &quot;&lt;strong&gt;&quot;, txt, &quot;&lt;/strong&gt;&quot; ] . Let’s look into what’s happening in our boldP parser. count is another combinator we have which allows us to consume a set number of matches for a parser. . In this instance, first, we consume two * characters. Then, we consume one or more alphanumeric characters, as well as spaces. Lastly, we consume another two * characters. . The more interesting thing happening here is that we are able to extract the matched string into a variable. We can do that with any parser we write, because all Parsers are monads. . In the last line of our boldP, we simply wrap the extracted text from between the ** with &lt;strong&gt; tags. . Let’s see this parser in action: . $ stack runghc myparser.hs &#39;** haskell **&#39; &quot;&lt;strong&gt; haskell &lt;/strong&gt;&quot; $ stack runghc myparser.hs &quot;**haskell has functions**&quot; &quot;&lt;strong&gt;haskell has functions&lt;/strong&gt;&quot; $ stack runghc myparser.hs haskell 1:1: unexpected &#39;h&#39; expecting &#39;*&#39; . Note that our parser only matches alphanumeric characters and spaces between the delimiters. It’ll be more robust when it matches pretty much anything between the delimiters. Feel free to implement that. . We can similarly parse strings into our custom datatypes, convert between them and more. We just need to remember that the datatype of the final output of parser is reflected in the datatype of the parser itself. . Conclusion . There are many more tools to discover in megaparsec itself, for various general and specific tasks. With this rather lengthy tutorial, I hope I have been able to get some idea of how we can get started with writing parsers. Feel free to share thoughts on the reddit thread. .",
            "url": "https://akagr.github.io/2017/01/19/beginners-guide-to-megaparsec.html",
            "relUrl": "/2017/01/19/beginners-guide-to-megaparsec.html",
            "date": " • Jan 19, 2017"
        }
        
    
  
    
        ,"post3": {
            "title": "Haskell Diary 2 - Algebra of Data Types",
            "content": "In every single Haskell guide I’ve been through, the term Algebraic Data Types is mentioned at least once. In most cases, the text simply moved on to how types are defined and used. A small minority actually tries to explain why Haskell’s data types are called Algebraic. An even smaller minority succeeded in getting the point across. Here’s me documenting what I’ve learned so far about them. Hopefully it’d be of some help for future Haskell learners. . Some background first . Bool is one of the simplest data type in Haskell. Its defined as: . data Bool = True | False . So when we say an expression is of type Bool, what values can it possibly evaluate to? It’d be either True or False. Correct? 2 possible values. . Here’s a quick home-made definition of a type Weekday: . data Weekday = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday . Now, if we say that an expression is of type Weekday, what are the possible values here. Any of the days we defined would be correct. That gives us 7 possible values whose type would be Weekday. . Let’s associate (in our minds) types with the number of values possible. So Bool is a 2. And Weekday is a 7. Similarly, if we check the max and min bounds of Int, we can put Int to 2 ^ 64 (because that many values are possible with Int data type). . This is something to keep in mind going forward. A data type can be associated to a number based on how many values an expression of that type can possibly evaluate to. Also, it is totally legit for a type to have infinite possible values (think String). . Sum . Now we can get to the Algebra part. Here’s the all-too-familiar definition of Maybe. . data Maybe a = Just a | Nothing -- Maybe a = a + 1 . Ignore the comment in the second line for now. . What are the possible values of Maybe a? That’s an absurd question unless we know what a is. . Let’s do it again. If an expression has type, say, Maybe Bool, what values can it have? Just True, Just False and Nothing. 3 values in total. That’s 2 boolean values plus 1 new Nothing value. . If a variable has type Maybe Weekday, the possible values are: . Just Monday | Just Tuesday | Just Wednesday | Just Thursday | Just Friday | Just Saturday | Just Sunday | Nothing | . So that’s 7 Weekday values plus 1 Nothing. Now check out the comment in the code snippet above again and see if it makes some sense. . The | operator in type definitions is acting like +. Data constructors which do not take any types (like Nothing) act as constants and represent a value in themselves. Let’s see one more example of this to cement this insight. . data Either a b = Left a | Right b -- Either a b = a + b . The possible values corresponding to type Either Bool Weekday are: . Left True | Left False | Right Monday | Right Tuesday | Right Wednesday | Right Thursday | Right Friday | Right Saturday | Right Sunday | . That’s 2 + 7 = 9 possible values in total. . Product . Like the sum, data types can also be defined as products of other data types. Here’s a quick example using a custom data type. . data Tuple a b = Tuple a b . Let’s apply some concrete type to both a and b and see what values are possible. . For Tuple Bool Bool, we have the following possible values: . Tuple True False | Tuple True True | Tuple False False | Tuple False True | . That’s 2 * 2 = 4 values. . For Tuple Bool Weekday, the possible values are: . Tuple True Monday | Tuple True Tuesday | Tuple True Wednesday | Tuple True Thursday | Tuple True Friday | Tuple True Saturday | Tuple True Sunday | Tuple False Monday | Tuple False Tuesday | Tuple False Wednesday | Tuple False Thursday | Tuple False Friday | Tuple False Saturday | Tuple False Sunday | . That’s 2 * 7 = 14 values. . While | acts like sum, specifying data types as composites is similarly equivalent to multiplication. Tuple Weekday Weekday will give 49 possible values. Because Weekday * Weekday or 7 * 7. . Data types follow algebraic laws . We can check this real quick by seeing how they follow distribution. For a refresher, distributive law is defined as . a * (b + c) == (a * b) + (a * c) . Let’s see if we can prove that this law holds for data types. Left side of equation first. We need a data type which corresponds to a * (b + c). We already know from above that Either b c is equivalent to b + c. To multiply it with a, we put that in a composite data type as follows. . data DLeft a b c = DLeft a (Either b c) -- DLeft a b c = a * (b + c) . Next, we’ll construct a data type which corresponds to right side of equation. . data DRight a b c = DRLeft a b | DRRight a c -- DRight a b c = (a * b) + (a * c) . All that’s left is to see if those two give the same number of possible values. Let’s put a = Bool, b = Bool and c = Weekday. . DLeft Bool Bool Weekday will have the following values: . DLeft True (Left True) | DLeft True (Left False) | DLeft True (Left Sunday) | DLeft True (Right Monday) | DLeft True (Right Tuesday) | DLeft True (Right Wednesday) | DLeft True (Right Thursday) | DLeft True (Right Friday) | DLeft True (Right Saturday) | DLeft True (Right Sunday) | DLeft False (Left True) | DLeft False (Left False) | DLeft False (Right Sunday) | DLeft False (Right Monday) | DLeft False (Right Tuesday) | DLeft False (Right Wednesday) | DLeft False (Right Thursday) | DLeft False (Right Friday) | DLeft False (Right Saturday) | DLeft False (Right Sunday) | . Which are be Bool * (Bool + Weekday) or 2 * (2 + 7) = 18 values in total. . Let’s see if the DRight Bool Bool Weekday offers the same number of values. . DRLeft False False | DRLeft False True | DRLeft True False | DRLeft True True | DRRight False Monday | DRRight False Tuesday | DRRight False Wednesday | DRRight False Thursday | DRRight False Friday | DRRight False Saturday | DRRight False Sunday | DRRight False Monday | DRRight True Tuesday | DRRight True Wednesday | DRRight True Thursday | DRRight True Friday | DRRight True Saturday | DRRight True Sunday | . That’s (Bool * Bool) + (Bool * Weekday) or (2 * 2) + (2 * 7) = 18 values. . Hence Proved! I always loved writing this :) . Exponents . Sum and product aren’t the only operations out there. One of the most common data types in Haskell is actually exponential. We know them as (-&gt;) or more generally as functions. This is a lot bigger topic but I will quickly list out how to visualise them. . For our example, we’ll use a simple function of type Weekday -&gt; Bool. How many ways are possible to write a function of that type while being total (not skipping any Weekdays). . myFunc Monday = True | myFunc Tuesday = True | myFunc Wednesday = True | myFunc Thursday = True | myFunc Friday = True | myFunc Saturday = True | myFunc Sunday = True | . Note that above is just one possible definition of such a function, not 7. This function can now take a Weekday (any one of them) and return a Bool. It may have been better to write it in short like myFunc _ = True. We’re talking about how many ways a function can be defined, instead of the number of possible values in previous operations. If we change any of the True in above definition to False, it’s a whole new function. What if we change a couple of True above to False? That’s yet another function. Writing all that will make this the longest post ever. So I’m gonna believe in reader and leave them to write all the possible definitions. In the end, the number of ways a similarly trivial function from Weekday -&gt; Bool can be defined is 128 which is 2 ^ 7 or Bool ^ Weekday. . To formalise it, a function a -&gt; b corresponds to algebraic operation b ^ a. . Conclusion . I wrote this post for a select species of programmers who like to know what they’re playing with with usability of that knowledge being non-consequential. I think that in general course of things, all the text above is not super handy and will probably not help someone write that awesome web server or parser. So, sincere apologies if I wasted your time. . For a fuller discussion on the algebra of data types, including recursive types, there’s a great series of posts here. . I’ll appreciate any and all feedback. Use this reddit thread. Thanks for reading! .",
            "url": "https://akagr.github.io/2016/04/10/haskell-diary-2-algebraic-data-types.html",
            "relUrl": "/2016/04/10/haskell-diary-2-algebraic-data-types.html",
            "date": " • Apr 10, 2016"
        }
        
    
  
    
        ,"post4": {
            "title": "What Promises Do That Observables Can’t",
            "content": "Note: This is a cross-post of an article I authored. The original was published at Modus Create, Inc. on April 06, 2016. . Nothing. . Observables are grabbing the spotlight as one of the cool new things Angular 2 is doing, despite having been around for some time. They are positioned to fully eclipse promises as the goto abstraction for dealing with async, among other things. Let’s dive into what Observables are and how they compare against promises in dealing with async data. . Promises and Observables . Promises are great. They were designed to be an answer to callback hell. Javascript’s tendency to keep edging to the right of the screen due to nesting has made many eyes bleed and brains explode. In comparison, the do this then this then that approach of promises was not only prettier and easier to read, it also provided a standard which could be embraced by developers to communicate with. Promises soon became the de-facto approach in most major frameworks and libraries. So much so in fact that the ES2015 specification incorporated promises as a core javascript API sans any third party library. . But promises act on data, and then return. They’re just sugar over the callback pattern. You can’t do much with a promise apart from getting a value or error out of it. How do we wrap a socket stream in a promise? Technically, it is never fulfilled. We just keep getting data out of it. We can use the progress method but it isn’t exactly meant for that and seems like a hack. . Enter Observables, the shiniest new abstraction for javascript devs. In reality though, Observables are simply the observer pattern at work. We’ve been attaching listeners to DOM events and reacting to events since the big bang. That pattern got abstracted to make it possible to interact with basically all data flow using the observer pattern. The resulting interface (or class/prototype/thing whatever you want to call it) was named Observable. Fitting. . Let’s see if we can reinforce this info by looking at a couple of examples. . /* This is how we&#39;ve been doing observer pattern */ document.addEventListener(&#39;mousemove&#39;, e =&gt; console.log(e.clientX)); /* This is how the new Observable looks like doing same thing */ Rx.Observable.fromEvent(document, &#39;mousemove&#39;) .subscribe(e =&gt; console.log(e.clientX)); . Why all the fuss, you ask? Because Observable doesn’t only work with DOM events. We can use it to deal with an amazing variety of data. . Rx.Observable.range(1, 10) .subscribe(e =&gt; console.log(e)); const sub = Rx.Observable.interval(1000) .subscribe(e =&gt; doThisEverySecond()); setTimeout(()=&gt; sub.dispose(), 3000); . Notice how we’re using the same interface (subscribe) to deal with totally different types of operations (including the document listener we added in the previous example). This is one of the major strengths of using Observables. We don’t need to wire our brains differently. If the data can be thought of as evented, stream or async, we can wrap it in an Observable. . The abstraction of Observables is cool in itself. But that’s only one of the two things that make it awesome. The other half is the extensive Rx.js library itself. It has an amazing collection of methods (called operators) that can be employed to bend data to our will including some really handy utility methods. I’ll let the code do the talking. . /* Print 1 to 10 instantly then print a number every 2 seconds */ Rx.Observable.range(1, 10) .concat( Rx.Observable.interval(2000) ) .subscribe(e =&gt; console.log(e)); /* Retry the Observable up to 2 times in case of error */ myHttpRequestObservable .retry(3) // 2 retries + 1 initial run .subscribe(e =&gt; console.log(e)); /* Print message if mouse moved within an area */ Rx.Observable.fromEvent(document, &#39;mousemove&#39;) .map(e =&gt; [e.clientX, e.clientY]) .filter(e =&gt; isInArea(e)) // isInArea return boolean .subscribe(e =&gt; console.log(&#39;Mouse moved!&#39;)); . This is just the tip of the iceberg. Check out their repo for all operators available out of the box. . Observables in Angular 2 . Angular 2 uses Rx.js Observables instead of promises for dealing with HTTP. This means, as we saw in the examples above, they come with some serious batteries included. That’s one of the reasons that HTTP operations in Angular 2 is so amazing. Here’s some code which consumes a quotes API via HTTP get. The result is an observable. . export class App { qlist: String[] = []; constructor (public http: Http) { } getQuote () { return this.http.get(&#39;http://quotesondesign.com/wp-json/posts?filter[orderby]=rand&amp;filter[posts_per_page]=1&#39;); } } . Note that since http.get method returns an Observable, merely calling the getQuote method won’t actually fire a request. An Observable starts emitting data when a subscriber is attached to it. Technically, this type of Observable is called a cold Observable. There’s also hot Observables that can emit data regardless of whether or not there are any subscriptions. . Now that we’ve seen how a simple request observable is defined in Angular 2, let’s see some operators on it. A code snippet is worth a thousand words: . class App { /* Existing methods … */ addQuote () { this.getQuote() .retry(2) // in case of error, try 1 more time .repeat(3) // do this 3 times .map(res =&gt; res.json()) // convert response to json .filter(res =&gt; res.length &gt; 0) // drop empty array responses .map(res =&gt; res[0].content.replace(/ &lt;.*? &gt;/g, &#39;&#39;)) .subscribe(quote =&gt; { this.qlist.push(quote); }, e =&gt; console.log(e.message)); } } . The above example could be found in action at this plunk. . Conclusion . Observables are powerful. And we’ve barely scratched the surface. They’re one of the proposed standards in ES2016. Looks like popular libraries are ending up in language specification these days :) . I’d love to hear your takeaways from this post and how you used observables in some new cool way. Any points for improving this post will be deeply appreciated as well. Use reddit or reach me on Twitter. .",
            "url": "https://akagr.github.io/2016/04/06/what-promises-do-that-observables-cant.html",
            "relUrl": "/2016/04/06/what-promises-do-that-observables-cant.html",
            "date": " • Apr 6, 2016"
        }
        
    
  
    
        ,"post5": {
            "title": "Haskell Diary 1 - Recursion",
            "content": "Haskell is the first pure functional programming language that I have had a serious contact with. I’m very much a noob right now but I’ve found that there’s a lot of gold to be found right from day 1 in functional world. So I’ve thought about documenting things which I found really cool, mind bending or which simply took a long time for me to wrap my head around (still, cool). . So… recursion. . I’ll get killed in the street if I said that Haskell can do recursion. Of course Haskell can do recursion. C can do recursion. Javascript can do recursion. Ruby, Java (and most other languages) can do it too. . The reason why I’m talking about recursion in Haskell is because of its support for infinite lists. More specifically, the reason I’m really talking about recursion is because of an example I came across which blew me away. Some background for the uninitiated first. . Recursion means a function calling itself . Bet anyone reading this already knew that. A classic example of recursion is fibonacci series. So here’s a naive program which probably every programmer has seen in their language(s) of choice. . fibonacci 0 = 0 fibonacci 1 = 1 fibonacci x = fibonacci (x - 1) + fibonacci (x - 2) . The reason it’s called naive is because it’s neither the most efficient nor the most elegant way of doing things. On my 2014 macbook pro with core i5, fibonacci 1 gives result instantly. fibonacci 25 seems a fraction of a second slower. fibonacci 50 hasn’t yielded results yet and I executed it 11 minutes ago. . Back on track, I came across following implementation of fibonacci while learning the basics of Haskell. It gives me results for 1000 instantaneously and doesn’t involves memoization or other state-dependent techniques. . fibs = 0 : 1 : zipWith (+) fibs (tail fibs) . Before diving in the down and low of it, following are (hopefully) self-explanatory examples of some other functions used here. . -- tail takes a list and gives it back after removing its first element tail [1, 2, 3, 4, 5] -- &gt; [2, 3, 4, 5] tail &quot;haskell diary&quot; -- &gt; &quot;askell diary&quot; -- zipWith takes a function and two lists and return the -- result of applying that function on corresponding elements zipWith (+) [1, 2, 3] [4, 5, 6] -- &gt; [5, 7, 9] zipWith (*) [1, 2, 3] [2..] -- &gt; [2, 6, 12] . Also, let’s reduce some noise by replacing zipWith (+) by a function which does the same but would look more at-home here. Also, rewrite the above code with our substituted function. . addLists = zipWith (+) -- addList [1, 2, 3] [4, 5, 6] gives [5, 7, 9] fibs = 0 : 1 : addLists fibs (tail fibs) . Makes better sense. Now, this code generates an infinitely long fibonacci sequence. It does that by recursively adding a list to itself only the second time it shifts it position (using tail) by a place. Let’s try and break it down. . fibs = 0 : 1 : addLists fibs (tail fibs) -- expanding by substituting fibs with its own definition fibs = 0 : 1 : addLists (0 : 1 : addLists fibs (tail fibs)) (1 : addLists fibs (tail fibs)) -- expanding again by replacing all instances of fibs by -- its definition above -- warning: keep your brains together now. I&#39;m just replacing stuff. fibs = 0 : 1 : addLists (0 : 1 : addLists (0 : 1 : addLists (0 : 1 : addLists fibs (tail fibs)) (1 : addLists fibs (tail fibs))) (1 : addLists (0 : 1 : addLists fibs (tail fibs)) (1 : addLists fibs (tail fibs))) (1 : addLists (0 : 1 : addLists (0 : 1 : addLists fibs (tail fibs)) (1 : addLists fibs (tail fibs))) (1 : addLists (0 : 1 : addLists fibs (tail fibs)) (1 : addLists fibs (tail fibs))) . And it will go on. Point of interest is that, after each expansion, we can apply addLists to get a number out. Let’s not do any further expansion (and risk fainting) and instead start working our way back to simplify by discarding and condensing. So we take as much as is concrete (does not require expansion) from the innermost list and discard the rest. . fibs = 0 : 1 : addLists (0 : 1 : addLists (0 : 1 : [1]) (1 : addLists (0 : 1 : [1]) (1 : addLists (0 : 1 : addLists (0 : 1 : [1]) (1 : addLists (0 : 1 : [1]) -- writing lists in common format (0 : 1 : [] == [0, 1]) fibs = 0 : 1 : addLists (0 : 1 : addLists [0, 1, 1] [1]) (1 : addLists [0, 1, 1] [1]) -- simplifying fibs = 0 : 1 : addLists (0 : 1 : [1]) (1 : [1]) -- writing lists in common format fibs = 0 : 1 : addLists ([0, 1, 1], [1, 1]) -- simplifying fibs = 0 : 1 : [1, 2] --&gt; [0, 1, 1, 2] . See? What we did was, we expanded fibs fully two times. And by discarding further expansions and simplifying, we added two new elements to our list. Note that we already began with 0 and 1. . We can easily write a small piece of code on top of this which returns the nth fibonacci number. . fibs = 0 : 1 : addLists fibs (tail fibs) fibonacci n = last $ take n fibs . Let’s say n = 30. So it’ll request 30 elements from fibs. Then, give us the last element of that 30 element list. i.e. the 30th element. . My biggest takeaway from this algorithm of fibonacci was that I need some time to get easy with infinite lists. I am used to approaching recursion from top-down. That means, start recursing and stop on some condition to yield result. That’s how our naive approach works too. . This code does the opposite. It starts from 0 and never stops (theoretically). It will never reach a last element. The reason we’re able to get away with writing this is that Haskell is lazy. It will only execute code if it really needs to. This is a huge departure from the strict evaluation that I’m used to. . So when we do a take 30 fibs, it’ll start recursing. And since since we told it to actually give us 30 elements, it will start simplifying too. It allows us to extract elements from its front as it goes on building that list further and further. Once it has given us enough elements, it gives up calculating more. It simply isn’t fussed about actually completing the list of all fibonacci numbers, in other words. Interesting, right? . While I know enough about recursion and Haskell library functions to try and explain how and why this code works, I imagine it’d take a bit of time for me to come up with such solutions myself. Hopefully sooner than later. . Let me know your thoughts over at reddit thread for this post. . Update 1: As /u/twistier pointed out over at reddit, a better definition of recursion would be a value, which may or may not be a function, being self referential. .",
            "url": "https://akagr.github.io/2016/01/31/haskell-diary-1-recursion.html",
            "relUrl": "/2016/01/31/haskell-diary-1-recursion.html",
            "date": " • Jan 31, 2016"
        }
        
    
  
    
        ,"post6": {
            "title": "How to write a JSPM package",
            "content": "Why . So I was assigned with building payment capabilities in my project at work and we decided to go with stripe. If you haven’t heard of it, it’s an awesome and developer friendly (looking at you, paypal!) payment gate which powers many cool web apps like shopify, kickstarter etc. . Now before I proceed further, let me tell you a couple of things about project and stripe. This is an angularjs app using JSPM (duh!) to manage dependencies. There’s already an awesome angular-stripe but it doesn’t include stripe.js, the base code for all the front-end stuff stripe exposes to developer. . Now there is obviously no problem in downloading this file, placing it somewhere in project and doing: . import &#39;lib/js/stripe&#39;; . It’d work. But it didn’t feel right for two reasons: . I had to create that folder just for stripe. This being an angular application, all of the internal libraries were written as services and stripe.js wouldn’t have fit in with them too well. | stripe.js is very much an external dependency and should go with other external dependencies in package.json. | In case you’ve not already guessed it, I decided to create a jspm package for stripe.js and import that into project through cli like any other dependency. I was surprised to see how little there is on the web to tell me how to do this. This post is aimed to remedy some of that. . How . I created a directory for this package (outside of project obviously) and initialised JSPM in it. . mkdir -p stripe-jspm/lib &amp;&amp; cd stripe-jspm jspm init -y . That gave me a package.json, config.js and an empty lib directory. . Next, I downloaded the stripe.js and placed it in lib. . Since stripe requires jQuery, I added it as dependency for our stripe-jspm package. . jspm install jquery . Finally, I needed to specify a main file in package.json which system.js uses to expose the module exported by the package. So I created an index.js in project root and populated it with the following: . import &#39;jquery&#39;; import &#39;./lib/stripe&#39;; export default Stripe; . And added it in package.json: . { &quot;main&quot;: &quot;index.js&quot;, // &lt;======== This right here &quot;jspm&quot;: { &quot;dependencies&quot;: { &quot;jquery&quot;: &quot;npm:jquery@^2.2.0&quot; }, &quot;devDependencies&quot;: { &quot;traceur&quot;: &quot;github:jmcriffey/bower-traceur@0.0.93&quot;, &quot;traceur-runtime&quot;: &quot;github:jmcriffey/bower-traceur-runtime@0.0.93&quot; } } } . Simple. Right? . With that out of the way, I had just some boilerplate stuff left. Adding package details in package.json, name, author… that kind of stuff. . That is pretty much it. I pushed this off to github and was able to install it as a dependency the correct way in my work project. . jspm install stripe=github:akagr/stripe-jspm . Here’s the finished thing: akagr/stripe-jspm . On . This package has some room for improvements. For example, we can probably remove traceur as a dev dependency since we’re not really using it in this package. And since it’s written in ES5 and earlier stuff, we’re not going to need it either. . This was my first time writing a package for jspm and I liked how I was able to do that and import it within a few minutes. Any suggestions for improvements to package or this post will be much appreciated. Feel free to shoot comments over at reddit. .",
            "url": "https://akagr.github.io/2016/01/18/how-to-write-a-jspm-package.html",
            "relUrl": "/2016/01/18/how-to-write-a-jspm-package.html",
            "date": " • Jan 18, 2016"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://akagr.github.io/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://akagr.github.io/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}